/*
**
* BEGIN_COPYRIGHT
*
* Copyright (C) 2008-2019 SciDB, Inc.
* All Rights Reserved.
*
* SciDB is free software: you can redistribute it and/or modify
* it under the terms of the AFFERO GNU General Public License as published by
* the Free Software Foundation.
*
* SciDB is distributed "AS-IS" AND WITHOUT ANY WARRANTY OF ANY KIND,
* INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
* NON-INFRINGEMENT, OR FITNESS FOR A PARTICULAR PURPOSE. See
* the AFFERO GNU General Public License for the complete license terms.
*
* You should have received a copy of the AFFERO GNU General Public License
* along with SciDB.  If not, see <http://www.gnu.org/licenses/agpl-3.0.html>
*
* END_COPYRIGHT
*/
#ifndef CCM_BRIDGE_H_
#define CCM_BRIDGE_H_

// header files from the ccm module
#include "Uuid.h"
// SciDB modules
#include <query/QueryID.h>
#include <rbac/SessionProperties.h>
// c++ standard libraries
#include <string>

/**
 * @file CcmBridge.h
 *
 * @ingroup Ccm
 *
 * @brief The client bridge is an interim means of communicating to the "southbound"
 * side of the client communications manager. The final goal is to call
 * directly into the SciDB (server) messaging framework.
 *
 * @details This bridge acts as a "scidb-in-process" old-school client application. (Much
 * like an iquery bolt-on to scidb. This allow thin clients rather than the
 * original approach of making clients be "neutered SciDB nodes".
 */
namespace scidb { namespace ccm { namespace bridge {

/**
 * A south-bound query associates the Ccm conversation identifier to the @c
 * queryID and the resulting output data associated with the queryID being
 * executed on the SciDB instance.
 */
class IngotProducer
{
  public:
    class iterator;
    /**
     * @param queryID the queryID generated by SciDB and used in the
     *                NetworkManager messaging and query processing
     *
     * @para resultPayload the resulting array data associated with the
     *                     execution of queryID.
     *
     * @para success true iff the execution of the query associated with queryID
     *                    was successful
     *
     *
     * @note The resultPayload contains the complete result of execution in the
     *       MVP version of the Ccm because the query execution and fetching of
     *       the data is a single synchronous call. In later phases of the Ccm
     *       development, the retrieval of data from the back-end will allow for
     *       retrieval portions of the the query result payload in smaller
     *       'ingots'.
     */
    IngotProducer(const scidb::QueryID& queryID, const std::string& resultPayload, bool success);
    IngotProducer() = default;

    bool success() const { return _success; }

    iterator begin();
    iterator end();

    // TODO Should we specify iterator traits? (which are deprecated in c++17)
    class iterator
    {
      public:
        iterator(const std::string& queryResultBuffer);
        iterator() = default;

        const std::string& operator*() const;
        iterator& operator++();

      private:
        std::string _queryResultBuffer;
    };

  private:
    scidb::QueryID _queryID;
    Uuid _ccmConversationId;
    std::string _resultPayload;
    bool _success{false};
};

/**
 * Authenticate with the back-end and associate the back-end connection with the
 * provided session identifier.
 *
 * @param username the username to authenticate with the back-end 4-way
 *                 handshake.
 *
 * @param challengeResponse the answer to provide to the back-end on the second
 *                          half of the 4-way handshake.
 *
 * @param ccmSessionId the ccm session identifier to associate with the back-end
 *                     @c scidb::Connection
 *
 * @param sessionPriority the priority (to determine which job queue) of the
 *                        back-end @c scidb::Connection
 *
 * @return true iff the back-end was able to successfully authenticate and
 *              create a back-end connection
 */
bool authenticate(const std::string& username,
                  const std::string& challengeResponse,
                  const Uuid& ccmSessionId,
                  int sessionPriority = scidb::SessionProperties::NORMAL);

/**
 * Execute a query on the back-end.
 *
 * @param afl the query string which the back-end needs to execute
 *
 * @param format the representation of the resulting array data
 *
 * @param ccmSessionId the Ccm session identifier to determine which
 *                     authenticated scib::Connection to use
 *
 * @param ccmConversationId the Ccm conversation identifier with which to
 *                          associate the back-end QueryID
 *
 * @return the resulting query information
 */
std::shared_ptr<IngotProducer> executeQuery(const std::string& afl,
                                            const std::string& format,
                                            const Uuid& ccmSessionId);

/**
 * Remove the Ccm session identifier from the @c scidb::Connection container,
 * and disconnect the back-end connection associated with a Ccm session
 * identifier.
 *
 * @param ccmSessionId the Ccm session identifier associated with the back-end
 *                     connection to remove
 */
bool destroy(const Uuid& ccmSessionId) noexcept;

bool operator==(const IngotProducer::iterator& lhs, const IngotProducer::iterator& rhs);

bool operator!=(const IngotProducer::iterator& lhs, const IngotProducer::iterator& rhs);

}}}  // namespace scidb::ccm::bridge

// LocalWords:  username
#endif
