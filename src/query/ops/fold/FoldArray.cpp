/*
**
* BEGIN_COPYRIGHT
*
* Copyright (C) 2014-2019 SciDB, Inc.
* All Rights Reserved.
*
* SciDB is free software: you can redistribute it and/or modify
* it under the terms of the AFFERO GNU General Public License as published by
* the Free Software Foundation.
*
* SciDB is distributed "AS-IS" AND WITHOUT ANY WARRANTY OF ANY KIND,
* INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,
* NON-INFRINGEMENT, OR FITNESS FOR A PARTICULAR PURPOSE. See
* the AFFERO GNU General Public License for the complete license terms.
*
* You should have received a copy of the AFFERO GNU General Public License
* along with SciDB.  If not, see <http://www.gnu.org/licenses/agpl-3.0.html>
*
* END_COPYRIGHT
*/

#include "FoldArray.h"

#include <query/TypeSystem.h>

namespace scidb {

/**
 * Compares two positions for equality by dimension-wise comparing
 * their coordinates for direct equality.
 *
 * The second argument may be longer than the first, allowing
 * comparison of the most- significant dimensions only.
 *
 * @param lpos Some position of dimension d
 * @param rpos Some position of dimension d' >= d
 * @return True if lpos == rpos up to and including dimension d.
 */
bool positionsEqual(const Coordinates& lpos, const Coordinates& rpos)
{
    SCIDB_ASSERT(rpos.size() >= lpos.size());
    for (size_t i = 0; i < lpos.size(); ++i) {
        if (lpos[i] != rpos[i]) {
            return false;
        }
    }
    return true;
}

FoldChunkIterator::FoldChunkIterator(FoldChunk& foldChunk,
                                     Array const& inputArray,
                                     std::shared_ptr<ConstArrayIterator> inputAttrIter,
                                     int iterationMode)
        : _foldChunk(foldChunk)
        , _inputArray(inputArray)
        , _inputAttrIter(inputAttrIter)
        , _inputChunkIter(nullptr)
        , _iterationMode(iterationMode)
        , _position(foldChunk.getArray().getArrayDesc().getDimensions().size())
        , _currPos()
        , _nullValue()
        , _trueValue()
        , _hasCurrent(false)
        , _inputChunkRow(0)
{
    const auto targetId = _getTargetAttribute();
    _inputChunkRow = targetId / _inputArray.getArrayDesc().getAttributes(true).size();
    _trueValue.setBool(true);
    SCIDB_ASSERT(_inputAttrIter);
    restart();
}

FoldChunkIterator::~FoldChunkIterator()
{
    // Nothing to destroy explicitly.
}

int FoldChunkIterator::getMode() const
{
    return _iterationMode;
}

Value const& FoldChunkIterator::getItem()
{
    if (_foldChunk.getAttributeDesc().isEmptyIndicator()) {
        return _trueValue;
    }
    else {
        if (_inputChunkIter->end()) {
            return _nullValue;
        }
        else {
            return _inputChunkIter->getItem();
        }
    }
}

bool FoldChunkIterator::isEmpty() const
{
    return false;
}

ConstChunk const& FoldChunkIterator::getChunk()
{
    return _foldChunk;
}

bool FoldChunkIterator::end()
{
    return !_hasCurrent;
}

bool FoldChunkIterator::_next()
{
    // Walk the logical space of the *chunk* (note: not the
    // whole array).  Missing locations become null values in
    // the new output attributes.
    const auto& firstPos = _inputChunkIter->getFirstPosition();
    const auto& lastPos = _inputChunkIter->getLastPosition();

    auto i = _currPos.size() - 1;
    while (_hasCurrent &&
           ++_currPos[i] > lastPos[i]) {
        if (i == 0) {
            _hasCurrent = false;
            break;
        }
        _currPos[i] = firstPos[i];
        --i;
    }

    return _hasCurrent;
}

void FoldChunkIterator::operator++()
{
    const auto& inputDims = _inputArray.getArrayDesc().getDimensions();

    // Seek forward to the next input position that corresponds to the
    // output attribute.  We want to 'fold' this input value into our output cell.
    while (_next()) {
        size_t absoluteChunkPos = _currPos.back() - inputDims.back().getStartMin();
        if (absoluteChunkPos == _inputChunkRow) {
            break;
        }
    }

    // Blindly set the position on the input.  If it exists, then
    // getItem() will return it.  If it doesn't, then getItem()
    // will return the null value.
    _inputChunkIter->setPosition(_currPos);
}

Coordinates const& FoldChunkIterator::getPosition()
{
    auto pos = _currPos;

    if (pos.size() > 1) {
        pos.resize(pos.size() - 1);
    }
    else {
        // Special case for the single-dimension input array.
        // The output array generated by fold() has one dimension and one
        // position along that dimension only.
        pos.back() = _foldChunk.getArray().getArrayDesc().getDimensions().back().getStartMin();
    }

    SCIDB_ASSERT(_position.size() == pos.size());
    _position = pos;  // Use _position just to satisfy the const ref return.
    return _position;
}

bool FoldChunkIterator::setPosition(Coordinates const& pos)
{
    // Copy the input position to resize it and match the
    // input array dimensionality.
    auto inputPos = pos;
    if (inputPos.size() > 1) {
        // If the input is not a single dimension, then resize.
        inputPos.resize(inputPos.size() + 1);
    }

    _setInputPosition(inputPos);
    return true;
}

void FoldChunkIterator::restart()
{
    // Assume that we have nothing, then see if that's true.
    _hasCurrent = false;

    // If there's a chunk here, then fold its cells into the
    // new attributes of the output array.
    if (!_inputAttrIter->end()) {
        _inputChunkIter = _inputAttrIter->getChunk().getConstIterator(_iterationMode);

        auto inputPos = _inputChunkIter->getPosition();
        _setInputPosition(inputPos);
    }
}

void FoldChunkIterator::_setInputPosition(Coordinates const& pos)
{
    // Copy the input position and ensure that it matches the
    // dimensionality of the input array.  We'll modify this
    // position in this method, below.
    auto inputPos = pos;
    const auto& inputDims = _inputArray.getArrayDesc().getDimensions();
    SCIDB_ASSERT(inputPos.size() == inputDims.size());

    // I, as the FoldChunkIterator, find my value at this location
    // from the input array in this way:
    //   The last dimension starting minimum plus
    //   The target attribute ID divided by the total number of attributes
    inputPos.back() =
        inputDims.back().getStartMin() +
        _inputChunkRow;

    // Remember where I am in the input chunk's logical space.
    _currPos = inputPos;

    // Blindly set the position on the input.  If it exists, then
    // getItem() will return it.  If it doesn't, then getItem()
    // will return the null value.
    _inputChunkIter->setPosition(inputPos);

    // setPosition always passes because I can always navigate to
    // where I want to be in the input chunk's logical space.
    _hasCurrent = true;
}

AttributeID FoldChunkIterator::_getTargetAttribute() const
{
    AttributeID targetId;

    if (_foldChunk.getAttributeDesc().isEmptyIndicator()) {
        // The empty attribute is an attribute that doesn't get mapped from
        // the input dimension space into a new attribute, so use the first
        // data attribute when navigating the input.  Otherwise, if we used
        // the empty bitmap's ID itself, we'd try to navigate to positions
        // that don't exist in the input array.  Additionally, if a location
        // is present for any one attribute, it is present for all attributes.
        targetId = _inputArray.getArrayDesc().getAttributes().firstDataAttribute().getId();
    }
    else {
        targetId = _foldChunk.getAttributeDesc().getId();
    }

    return targetId;
}

FoldChunk::FoldChunk(FoldArrayIterator& foldArrayIter,
                     Array const& inputArray)
    : _foldArrayIter(foldArrayIter)
    , _inputArray(inputArray)
    , _inputAttrIter(nullptr)
    , _firstPosition()
    , _lastPosition()
{
}

FoldChunk::~FoldChunk()
{
    // Nothing to destroy explicitly.
}

const ArrayDesc& FoldChunk::getArrayDesc() const
{
    return _foldArrayIter.getArray().getArrayDesc();
}

const AttributeDesc& FoldChunk::getAttributeDesc() const
{
    return _foldArrayIter.getAttributeDesc();
}

Coordinates const& FoldChunk::getFirstPosition(bool withOverlap) const
{
    if (_firstPosition.empty()) {
        _firstPosition = _inputAttrIter->getChunk().getFirstPosition(withOverlap);
        if (_firstPosition.size() > 1) {
            _firstPosition.resize(_firstPosition.size() - 1);
        }
    }

    return _firstPosition;
}

Coordinates const& FoldChunk::getLastPosition(bool withOverlap) const
{
    if (_lastPosition.empty()) {
        _lastPosition = _inputAttrIter->getChunk().getLastPosition(withOverlap);
        if (_lastPosition.size() > 1) {
            _lastPosition.resize(_lastPosition.size() - 1);
        }
    }

    return _lastPosition;
}

std::shared_ptr<ConstChunkIterator> FoldChunk::getConstIterator(int iterationMode) const
{
    auto& mthis = const_cast<FoldChunk&>(*this);
    return std::make_shared<FoldChunkIterator>(mthis,
                                               mthis._inputArray,
                                               mthis._inputAttrIter,
                                               iterationMode);
}

CompressorType FoldChunk::getCompressionMethod() const
{
    return _foldArrayIter.getAttributeDesc().getDefaultCompressionMethod();
}

Array const& FoldChunk::getArray() const
{
    return _foldArrayIter.getArray();
}

FoldArrayIterator& FoldChunk::getArrayIter()
{
    return _foldArrayIter;
}

void FoldChunk::updateInputIter(std::shared_ptr<ConstArrayIterator> inputAttrIter)
{
    _inputAttrIter = inputAttrIter;
    _firstPosition.clear();
    _lastPosition.clear();
}

FoldArrayIterator::FoldArrayIterator(Array const& inputArray,
                                     FoldArray& foldArray,
                                     const AttributeDesc& foldArrayAttr)
    : ConstArrayIterator(foldArray)
    , _inputArray(inputArray)
    , _foldArray(foldArray)
    , _foldArrayAttr(foldArrayAttr)
    , _inputAttrIter(nullptr)
    , _foldChunk(*this, inputArray)
    , _position(_foldArray.getArrayDesc().getDimensions().size())
    , _hasCurrent(false)
{
    restart();
}

FoldArrayIterator::~FoldArrayIterator()
{
    // Nothing to destroy explicitly.
}

bool FoldArrayIterator::end()
{
    return !_hasCurrent;
}

void FoldArrayIterator::operator++()
{
    if (!_inputAttrIter->end()) {
        ++(*_inputAttrIter);
    }

    AttributeID targetId = _getTargetAttribute();

    // While we're not at the end of the input array and
    // we haven't found a chunk containing the position for
    // the desired output attribute, keep looking.
    // This is tricky.  This comes down to enforcing row-major
    // ordering across the attributes of a chunk.  There's a
    // limitation in the SG where all the attributes for a
    // given cell have to originate on the same instance (put
    // another way, I can't have instance 1 generate attribute
    // 'a' at position p and have instance 2 generate attribute
    // 'b' at position p) because it violates row-major ordering
    // in our system.  By requiring the chunk interval to cover
    // the entire range of the last dimension, we preserve
    // row-major ordering because all of the values for all
    // attributes in the output array are generated from one
    // instance (satisfying StreamArray particularly).
    while (!_inputAttrIter->end() &&
           !_isTargetForAttribute(targetId)) {
        ++(*_inputAttrIter);
    }

    _hasCurrent = !_inputAttrIter->end();
}

Coordinates const& FoldArrayIterator::getPosition()
{
    auto pos = _inputAttrIter->getPosition();

    if (pos.size() > 1) {
        pos.resize(pos.size() - 1);
    }

    SCIDB_ASSERT(_position.size() == pos.size());
    _position = pos;
    return _position;
}

bool FoldArrayIterator::setPosition(Coordinates const& pos)
{
    // Moving backwards is not supported.
    auto curPos = getPosition();
    auto compareResult = coordinatesCompare(pos, curPos);
    ASSERT_EXCEPTION(compareResult >= 0,
                     "_fold() only moves forwards in the coordinate space");

    // We're getting asked to move ahead, figure-out if
    // we're already there.
    auto alreadyThere = compareResult == 0;

    if (!alreadyThere) {
        // We're not already at the desired location, so
        // move until at least we're on the right "row"
        // of the input chunk.
        while (!_inputAttrIter->end() &&
               !positionsEqual(pos,
                               _inputAttrIter->getPosition())) {
            ++(*_inputAttrIter);
        }

        AttributeID targetId = _getTargetAttribute();

        // While we're not at the end of the input array and
        // we haven't found a chunk containing the position for
        // the desired output attribute, keep looking.  At least
        // know we're on the right "row" of the input.
        while (!_inputAttrIter->end() &&
               !_isTargetForAttribute(targetId)) {
            ++(*_inputAttrIter);
        }
    }

    _hasCurrent = !_inputAttrIter->end();
    return _hasCurrent;
}

void FoldArrayIterator::restart()
{
    const AttributeDesc* targetAttrPtr = nullptr;

    if (_foldArrayAttr.isEmptyIndicator()) {
        auto ebm = _inputArray.getArrayDesc().getEmptyBitmapAttribute();
        SCIDB_ASSERT(ebm);
        targetAttrPtr = ebm;
    }
    else {
        const auto& inputArrayAttrs = _inputArray.getArrayDesc().getAttributes(true);
        const auto targetAttrId = _foldArrayAttr.getId() % inputArrayAttrs.size();
        targetAttrPtr = &inputArrayAttrs.findattr(targetAttrId);
    }

    SCIDB_ASSERT(targetAttrPtr);
    _inputAttrIter = _inputArray.getConstIterator(*targetAttrPtr);
    AttributeID targetId = _getTargetAttribute();

    while (!_inputAttrIter->end() &&
           !_isTargetForAttribute(targetId)) {
        ++(*_inputAttrIter);
    }

    _hasCurrent = !_inputAttrIter->end();
}

ConstChunk const& FoldArrayIterator::getChunk()
{
    _foldChunk.updateInputIter(_inputAttrIter);
    return _foldChunk;
}

const AttributeDesc& FoldArrayIterator::getAttributeDesc() const
{
    return _foldArrayAttr;
}

FoldArray& FoldArrayIterator::getArray()
{
    return _foldArray;
}

Array const& FoldArrayIterator::getInputArray()
{
    return _inputArray;
}

bool FoldArrayIterator::_isTargetForAttribute(AttributeID targetId) const
{
    const auto& inputDims = _inputArray.getArrayDesc().getDimensions();
    const auto& inputAttrs = _inputArray.getArrayDesc().getAttributes(true);
    const auto curPos = _inputAttrIter->getPosition();
    Coordinate target = (targetId / inputAttrs.size()) + inputDims.back().getStartMin();
    return ((target <= (curPos.back() + inputDims.back().getChunkInterval() - 1)) &&
            (target >= curPos.back()));
}

AttributeID FoldArrayIterator::_getTargetAttribute() const
{
    AttributeID targetId;

    if (_foldArrayAttr.isEmptyIndicator()) {
        targetId = _inputArray.getArrayDesc().getAttributes().firstDataAttribute().getId();
    }
    else {
        targetId = _foldArrayAttr.getId();
    }

    return targetId;
}

FoldArray::FoldArray(std::shared_ptr<Query> query,
                     const ArrayDesc& desc,
                     std::shared_ptr<Array> inputArray)
    : Array(inputArray)
    , _desc(desc)
{
    // basic sanity checking
    SCIDB_ASSERT(query);
    SCIDB_ASSERT(inputArray);

    _query = query;
}

FoldArray::~FoldArray()
{
    // Nothing to destroy explicitly.
}

ArrayDesc const& FoldArray::getArrayDesc() const
{
    return _desc;
}

std::shared_ptr<ConstArrayIterator> FoldArray::getConstIteratorImpl(
    const AttributeDesc& foldArrayAttr) const
{
    auto& mthis = const_cast<FoldArray&>(*this);
    SCIDB_ASSERT(getPipe(0));
    return std::make_shared<FoldArrayIterator>(*getPipe(0),
                                               mthis,
                                               foldArrayAttr);
}

std::shared_ptr<Query> FoldArray::getQuery()
{
    std::shared_ptr<Query> query = Query::getValidQueryPtr(_query);
    return query;
}

}  // namespace scidb
